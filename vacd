#!/usr/bin/python
#
#  vacd - Vac daemon which runs on factory nodes
#
#  Andrew McNab, University of Manchester.
#  Copyright (c) 2013-4. All rights reserved.
#
#  Redistribution and use in source and binary forms, with or
#  without modification, are permitted provided that the following
#  conditions are met:
#
#    o Redistributions of source code must retain the above
#      copyright notice, this list of conditions and the following
#      disclaimer. 
#    o Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials
#      provided with the distribution. 
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
#  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
#  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
#  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.
#
#  Contacts: Andrew.McNab@cern.ch  http://www.gridpp.ac.uk/vac/
#

import uuid
import os, errno, sys
import json
import time
import subprocess
import socket
import shutil
import tempfile
import hashlib,base64
import multiprocessing
import libvirt
import VAC
import stat

def vacLibvirtErrorHandler(ctxt, err):
    global errno    
    errno = err            
      
def pollFactories():

   # Total HS06 of running/starting VMs per vmtype
   factoryVmtypeTotals             = {}
   
   # Time in Unix seconds of the most recent abort, for each vmtype
   factoryVmtypeLastAborts         = {}
   
   # Number of VMs starting or not yet running for at least fizzle_seconds, for each vmtype
   factoryVmtypeNumberBeforeFizzle = {}

   # Initialise
   for vmtypeName, vmtype in VAC.vmtypes.iteritems():
      if vmtype['share'] > 0.0:
        factoryVmtypeTotals[vmtypeName]             = 0.0
        factoryVmtypeLastAborts[vmtypeName]         = 0
        factoryVmtypeNumberBeforeFizzle[vmtypeName] = 0

   salt = base64.b64encode(os.urandom(32))
   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
   sock.settimeout(VAC.udpTimeoutSeconds)

   for factoryName in VAC.factories:
      try:
         sock.sendto(json.dumps({'space':VAC.spaceName, 'cookie':hashlib.sha256(salt + factoryName).hexdigest(), 
                              'method':'status'}),(factoryName,995))
      except socket.error as msg:
         pass

   while True:
   
      try:
           data, addr = sock.recvfrom(10240)
                      
           try:
                response = json.loads(data)
           except:
              VAC.logLine('json.loads failed for ' + data)
              continue

           if 'space' 			in response and \
              'cookie' 			in response and \
              'factoryname'		in response and \
              'method'			in response and \
              response['space']  == VAC.spaceName and \
              response['method'] == 'status' and \
              response['cookie'] == hashlib.sha256(salt + response['factoryname']).hexdigest() :

              if 'state'		in response and \
                 'vmname'		in response and \
                 'vmtype'		in response and \
                 'hs06'			in response and \
                 response['vmtype']	in VAC.vmtypes and \
                 (response['state'] == VAC.VacState.starting or response['state'] == VAC.VacState.running) and \
                 VAC.vmtypes[response['vmtype']]['share'] > 0.0:

                   # we only have to add hs06/share for this vmtype to get normalisation at the end automatically
                   factoryVmtypeTotals[response['vmtype']] += response['hs06'] / VAC.vmtypes[response['vmtype']]['share']
                   VAC.logLine(response['factoryname'] + ' responds, running total for ' + response['vmtype'] +
                               ' now ' + str(factoryVmtypeTotals[response['vmtype']]) + ' HS06')
                               
                   if response['state'] == VAC.VacState.starting:
                           # starting counts as before fizzle point
                           factoryVmtypeNumberBeforeFizzle[response['vmtype']] += 1
                   elif response['state'] == VAC.VacState.running and 'vmtypes' in response and \
                        int(time.time()) < (response['vmtypes'][response['vmtype']]['started'] + VAC.vmtypes[response['vmtype']]['fizzle_seconds']):
                           # running for less than fizzle_seconds counts too
                           factoryVmtypeNumberBeforeFizzle[response['vmtype']] += 1
                   
              if 'vmtypes' in response:
                for vmtypeName, vmtypeOutcome in response['vmtypes'].iteritems():

                  try:
                    abortTime = None

                    if 'messagetime' in vmtypeOutcome and 'message' in vmtypeOutcome and vmtypeOutcome['message'][0:3].isdigit():
                      # if message with code provided, then we always use it for decisions
                      messagecode=int(vmtypeOutcome['message'][0:3])
                      if (messagecode >= 300) and (messagecode <= 599):
                        # 300 is no work, 400 is banned, 500 is problem with VM/Site
                        abortTime = vmtypeOutcome['messagetime']
                    else:
                      # no message, so we have to use times to identify fizzles
                      if (vmtypeName != response['vmtype'] or response['state'] == VAC.VacState.shutdown) and \
                         started in vmtypeOutcome and heartbeat in vmtypeOutcome and \
                         vmtypeOutcome['heartbeat'] < (vmtypeOutcome['started'] + VAC.vmtypes[vmtypeName]['fizzle_seconds']):
                        abortTime = vmtypeOutcome['heartbeat']

                    # if this is the most recent abort of this vmtype anywhere in this space
                    if abortTime and (abortTime > factoryVmtypeLastAborts[vmtypeName]):
                      factoryVmtypeLastAborts[vmtypeName] = abortTime
                      
                  except:
                    continue     
     
      except socket.error as msg:
           break

   VAC.logLine('Final totals ' + str(factoryVmtypeTotals) + ' HS06')

   preferredVmtypeName = None

   # Go through the vmtypes, trying to pick the best one to start:
   # - Target share must be > 0.0
   # - If there has been an abort, it must be at least backoff_second ago
   # - We extend this backoff by fizzle_seconds if any other VMs of this
   #     vmtype are starting or not yet running for fizzle_seconds
   #
   # This procedure aims to give one VM the chance to try a vmtype when the
   # initial backoff_seconds following an abort expires. Rather than have
   # many VMs all trying to run as vmtype immediately. In practice, more 
   # than one may win the race to be the "first" to try, but this should
   # still be a manageable number for the experiment's Matcher/Task Queue. 
      
   for vmtypeName, vmtype in VAC.vmtypes.iteritems():
      if vmtype['share'] > 0.0:
                      VAC.logLine(vmtypeName + ' at ' + str(int(time.time())) + ' LastAbort was ' + str(factoryVmtypeLastAborts[vmtypeName]) + ' needs to be < ' + 
                          str(int(time.time()) - vmtype['backoff_seconds'] - VAC.vmtypes[vmtypeName]['fizzle_seconds'] * (factoryVmtypeNumberBeforeFizzle[vmtypeName] > 0)) +
                          ', ' + str(factoryVmtypeNumberBeforeFizzle[vmtypeName]) + ' BeforeFizzles')
      if ((vmtype['share'] > 0.0) and 
          (factoryVmtypeLastAborts[vmtypeName] 
              < (int(time.time()) 
                 - vmtype['backoff_seconds'] 
                 - VAC.vmtypes[vmtypeName]['fizzle_seconds'] * (factoryVmtypeNumberBeforeFizzle[vmtypeName] > 0)))):
                      if not preferredVmtypeName:
                        preferredVmtypeName = vmtypeName
                      elif factoryVmtypeTotals[vmtypeName] < factoryVmtypeTotals[preferredVmtypeName]:
                        preferredVmtypeName = vmtypeName

   return preferredVmtypeName

def vacOneCycle():

   # Update factory heartbeat file
   VAC.createFile('/var/lib/vac/factory-heartbeat', str(int(time.time())) + '\n')
   os.chmod('/var/lib/vac/factory-heartbeat', stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH)

   readConfError = VAC.readConf()
   
   if readConfError:
     VAC.logLine('Reading configuration fails with: ' + readConfError)
     return
      
   # Check we can talk to the hypervisor
   # This is important at (re)start time and lets us wait till things are ok
   try:
     conn = libvirt.open(None)
   except:
     VAC.logLine('Failed to open libvirt connection')
     return
   else:     
     conn.close()

   if VAC.deleteOldFiles:
     VAC.cleanupVirtualmachineFiles()

   VAC.cleanupExports()

   if not os.path.exists('/var/lib/vac/factory-daily') or \
      time.time() > (os.stat('/var/lib/vac/factory-daily').st_ctime + 86400.0):
         VAC.createFile('/var/lib/vac/factory-daily', '')
   
         if VAC.versionLogger:
           try:
             sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
             sock.sendto(json.dumps({'space':VAC.spaceName, 'factory':os.uname()[1], 'version':VAC.vacVersion}),
                         ('vac-version-logger.gridpp.ac.uk',8884))
             sock.close()
           except:
             pass
     
   conn = libvirt.open(None)
     
   try:
       conn.networkLookupByName('vac_' + VAC.natNetwork)
   except:
       VAC.logLine('No libvirt network vac_' + VAC.natNetwork + ' defined for NAT.')       

       if not VAC.createNetwork(conn):
        conn.close()
        return

   conn.close()
     
   VAC.logLine('VMs available to this factory machine: ' + str(VAC.virtualmachines))
   VAC.logLine('VM Types configuration: ' + str(VAC.vmtypes))
   VAC.logLine('Factories in the space ' + VAC.spaceName + ': ' + str(VAC.factories))
   
   # These are updated at the END of each cycle of the for loop
   # --> So we do not use  continue  within this loop! <--
   totalCount    = 0
   runningCount  = 0
   
   for vmname in VAC.virtualmachines:
   
     vm = VAC.VacVM(vmname)

     if hasattr(vm, 'shutdownMessage') and vm.shutdownMessage:
      VAC.logLine(vm.name + ' is ' + vm.state + ' (' + str(vm.vmtypeName) + ' "' + vm.shutdownMessage + '" ' + str(vm.uuidStr) + ')')
     else:
      VAC.logLine(vm.name + ' is ' + vm.state + ' (' + str(vm.vmtypeName) + ' "" ' + str(vm.uuidStr) + ')')
     
     if vm.state == VAC.VacState.running:
       # VM is happily running so we redo the machine's heartbeat file
       vm.createHeartbeatFile()

       # ah, but are WE happy that it is still running?
       try:
           if int(time.time()) > vm.shutdownTime:
             VAC.logLine('VM ' + vm.name + ' has passed shutdowntime without stopping - destroying!')
             vm.destroyVM()
       except:
           pass
                                                       
     elif vm.state == VAC.VacState.zombie:
       # VM running but no corresponding vac directory structure
       # We kill zombies on sight! 
       VAC.logLine('VM ' + vm.name + ' running without vac directories - destroying!')
       vm.destroyVM()
       
     elif vm.state == VAC.VacState.paused:
       # suspended internally somehow? kill it to be safe
       VAC.logLine('VM ' + vm.name + ' paused without shutting down - destroying!')
       vm.destroyVM()

     if vm.state == VAC.VacState.starting and vm.vmtypeName:
       VAC.logLine('VM ' + vm.name + ' still in starting state in a new cycle - cleaning up!')
       # If VM is still starting and we've come round again, then starting failed!
       vm.state = VAC.VacState.shutdown
       # Something has gone wrong, so we clean up
       VAC.cleanupByNameUUID(vm.name, vm.vmtypeName, vm.uuidStr)

     if vm.state == VAC.VacState.shutdown:
       # create the finished file for the responder if not already there
       if vm.started and not vm.finishedFile:
               vm.writeAccounting()
               if VAC.vmtypes[vm.vmtypeName]['log_machineoutputs']:
                 vm.logMachineoutputs()
               VAC.logLine('Create finished file for ' + vm.name)
               vm.createFinishedFile()

       elif not vm.finishedFile:
               VAC.logLine('No finished file but no started time for ' + vm.name)
  
       # count up the running VMs' CPUs on the this factory
       totalCpusForCount = 0
  
       for vmnameForCount in VAC.virtualmachines:
          vmForCount = VAC.VacVM(vmnameForCount)

          if vmForCount.state == VAC.VacState.running:
              totalCpusForCount += vmForCount.cpus
       
       if (totalCpusForCount + VAC.cpuPerMachine) <= VAC.numCpus:
         # as VM is shutdown, we see if we can restart it but only 
         # if cpu limit from cpu_total or /proc/cpuinfo allows
         VAC.logLine('Query factories and try to recreate ' + vm.name)
         preferredVmtypeName = pollFactories()
       
         if preferredVmtypeName:
           VAC.logLine('Creating ' + vm.name + ' with vmtype ' + preferredVmtypeName)
           createError = vm.createVM(preferredVmtypeName)

           if createError:
             VAC.logLine('VM creation fails with: ' + createError)
             VAC.createFile('/var/lib/vac/factory-error', 'VM creation fails with: ' + createError)
             os.chmod('/var/lib/vac/factory-error', stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH)
           else:
             # we update heartbeat after creating a VM in case that took a while
             # (several minutes for Xen, without COW disk images)
             VAC.createFile('/var/lib/vac/factory-heartbeat', str(int(time.time())) + '\n')
             os.chmod('/var/lib/vac/factory-heartbeat', stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH)

             # if no VM creation errors, then cleanup any old message   
             try:
               os.remove('/var/lib/vac/factory-error')
             except OSError:
               pass
         else:
           VAC.logLine('No vmtype suitable for creation in this cycle')
       else:
         VAC.logLine('VM not recreated due to cpu_total or /proc/cpuinfo limit (' + str(VAC.numCpus) + ')')

     # finished with this vm, update counts
     totalCount += 1

     # the createVM and destroyVM methods update VacVM.state
     if vm.state == VAC.VacState.running:
       runningCount += 1

   # finished with all VMs, so output counts for Nagios etc
   VAC.createFile('/var/lib/vac/counts', 'total=%d running=%d\n' % (totalCount,runningCount))
   os.chmod('/var/lib/vac/counts', stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH)

def vacResponder():

   si = file('/dev/null', 'r')
   os.dup2(si.fileno(), sys.stdin.fileno())

   so = file('/var/log/vacd-responder', 'a+')
   os.dup2(so.fileno(), sys.stdout.fileno())
          
   se = file('/var/log/vacd-responder', 'a+', 0)     
   os.dup2(se.fileno(), sys.stderr.fileno())
 
   VAC.createFile('/var/lib/vac/responder.pid', str(os.getpid()) + '\n')

   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
   sock.settimeout(60.0)
   sock.bind(('', 995))
   
   VAC.logLine('vac responder starts')
   
   VAC.setProcessName('vacd-responder')

   while True:
   
     try:
       close(so)
     except:
       pass
           
     so = file('/var/log/vacd-responder', 'a+')
     os.dup2(so.fileno(), sys.stdout.fileno())
          
     try:
       close(se)
     except:
       pass

     se = file('/var/log/vacd-responder', 'a+', 0)     
     os.dup2(se.fileno(), sys.stderr.fileno())

     readConfError = VAC.readConf()

     if readConfError:
       VAC.logLine('Reading configuration fails with: ' + readConfError)
       time.sleep(60.0)
       continue
          
     try:
       pr = open('/var/lib/vac/responder.pid', 'r')
       pid = int(pr.read().strip())
       pr.close()
       
       if pid != os.getpid():
         VAC.logLine('os.getpid ' + os.getpid() + ' does not match responder.pid ' + pid + ' - exiting')
         break
                
     except:
       VAC.logLine('no responder.pid - exiting')
       break

     # so log file is updated before we start waiting        
     sys.stdout.flush()
     sys.stderr.flush()

     # Update responder heartbeat file
     VAC.createFile('/var/lib/vac/responder-heartbeat', str(int(time.time())) + '\n')
     os.chmod('/var/lib/vac/responder-heartbeat', stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH)

     try:
        data, addr = sock.recvfrom(1024)
     except socket.error as msg:
        continue;

     try:
        query = json.loads(data)
     except:
        continue
     
     if ('space'  in query and 
         'cookie' in query and 
         'method' in query and 
         query['space']  == VAC.spaceName and
         query['method'] == 'status'):
          
         VAC.logLine("Received " + data + " from " + str(addr))
    
         for vmName in VAC.virtualmachines:
         
           # initialise defaults in case no vmtype directories for this vmName
           vmState      = VAC.VacState.shutdown
           vmCtime      = None
           vmVmtypeName = None
           vmHS06       = VAC.hs06PerMachine

           vmtypesDict = {}
           
           for vmtypeName, vmtype in VAC.vmtypes.iteritems():

              try:
                  dirslist = os.listdir('/var/lib/vac/machines/' + vmName + '/' + vmtypeName)
              except:
                  continue

              newestUUIDByVmtype = None
              newestCtime        = None

              for onedir in dirslist:
                 try:
                     ctime = int(os.stat('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + onedir + '/created').st_ctime)
                 except:
                     pass
                 else:
                     if not newestUUIDByVmtype or (ctime > newestCtime):
                       newestCtime        = ctime
                       newestUUIDByVmtype = onedir

              if newestUUIDByVmtype:
                
                try:
                  startedStat = os.stat('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUIDByVmtype + '/started')
                  timeStarted = int(startedStat.st_ctime)
                except:
                  timeStarted = None
                                    
                try:
                  heartbeatStat = os.stat('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUIDByVmtype + '/heartbeat')
                  timeHeartbeat = int(heartbeatStat.st_ctime)
                except:
                  timeHeartbeat = None

                try:                  
                  f = open('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUIDByVmtype + '/shared/machinefeatures/hs06', 'r')
                  hs06 = float(f.readline().strip())
                  f.close()
                except:
                  hs06 = VAC.hs06PerMachine

                try:                  
                  f = open('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUIDByVmtype + '/heartbeat', 'r')
                  oneLine = f.readline()
                  f.close()
                                    
                  cpuSeconds = int(oneLine.split(' ')[0])
                  try:
                    cpuPercentage = float(oneLine.split(' ')[1])
                  except:
                    cpuPercentage = None
                    
                except:
                  cpuSeconds    = None
                  cpuPercentage = None

                hasFinished = os.path.exists('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUIDByVmtype + '/finished')

                # some hardcoded timeouts in case old files are left lying around 
                # this means that old files are ignored when working out the state
                if (timeStarted and 
                    timeHeartbeat and 
                    (timeHeartbeat > int(time.time() - 3600)) and
                    not hasFinished):
                          newestVmState = VAC.VacState.running
                elif not timeStarted and (newestCtime > int(time.time() - 3600)):
                          newestVmState = VAC.VacState.starting
                else:
                          newestVmState = VAC.VacState.shutdown

                try:
                  f = open('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUIDByVmtype + '/shared/machineoutputs/shutdown_message')
                  shutdownMessage = f.readline().strip()
                  f.close()
                  timeShutdownMessage = int(os.stat('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUIDByVmtype + 
                                                    '/shared/machineoutputs/shutdown_message').st_ctime)
                except:
                  shutdownMessage     = None                                    
                  timeShutdownMessage = None
                                
                vmtypesDict[vmtypeName] = {
                                            'uuid'		: newestUUIDByVmtype,
                                            'created'		: newestCtime,
                                            'started'		: timeStarted,
                                            'heartbeat'		: timeHeartbeat,
                                            'cpuseconds'	: cpuSeconds,
                                            'cpupercentage'	: cpuPercentage,
                                            'message'		: shutdownMessage,
                                            'messagetime'	: timeShutdownMessage
                                          }
                                  
                # if this is also the newest one for the whole VM, then save for later
                if not vmCtime or (newestCtime > vmCtime):
                    vmCtime      = newestCtime
                    vmState      = newestVmState
                    vmVmtypeName = vmtypeName

                    # override the factory-wide default in case it changed
                    if vmState == VAC.VacState.running:
                      vmHS06 = hs06
                                                        
           VAC.logLine(vmName + ' is ' + str(vmState) + ' (' + str(vmVmtypeName) + ', started ' + str(vmCtime) + ')')

           try:
             sock.sendto(json.dumps({
                'version'	: VAC.vacVersion,
                'space'		: VAC.spaceName,
                'hs06'		: vmHS06,
                'vmname'	: vmName,
                'state'		: vmState,
                'vmtype'	: vmVmtypeName,
                'cookie'	: query['cookie'],
                'method'	: query['method'],
                'vmtypes'	: vmtypesDict,
                'factoryname'	: socket.gethostbyaddr(socket.gethostname())[0]
                              }), addr)

           except socket.error as msg:
             pass

   sys.exit(0) # if we break out of while loop then we exit

#
# PROGRAM MAIN !!!
# 

libvirt.registerErrorHandler(vacLibvirtErrorHandler, 'context')

if __name__ == '__main__':

    if (os.fork() != 0):
      sys.exit() # first parent

    else:
      os.chdir("/")
      os.setsid()
      os.umask(0) 

      if os.fork() != 0:
        sys.exit() # second parent

      else:
             
        if os.fork() == 0:

          vacResponder()

        else:
          try:
             os.remove('/var/lib/vac/factory-daily')
          except:
             pass

          VAC.createFile('/var/lib/vac/factory.pid', str(os.getpid()) + '\n')
          
          VAC.setProcessName('vacd-factory')

          si = file('/dev/null', 'r')
          os.dup2(si.fileno(), sys.stdin.fileno())

          while True:
          
            try:
              close(so)
            except:
              pass
           
            so = file('/var/log/vacd-factory', 'a+')
            os.dup2(so.fileno(), sys.stdout.fileno())
          
            try:
              close(se)
            except:
              pass

            se = file('/var/log/vacd-factory', 'a+', 0)     
            os.dup2(se.fileno(), sys.stderr.fileno())

            try:
               pf = open('/var/lib/vac/factory.pid', 'r')
               pid = int(pf.read().strip())
               pf.close()
       
               if pid != os.getpid():
                 print 'new factory.pid - exiting'
                 break
                
            except:
               print 'no factory.pid - exiting'
               break

            VAC.logLine('=============== Start cycle ===============')

            vacOneCycle()

            VAC.logLine('================ End cycle ================')

            sys.stdout.flush()
            sys.stderr.flush()
            time.sleep(VAC.cycleSeconds)
 
          sys.exit(0) # if we break out of the while loop, then we exit
          