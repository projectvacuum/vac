#!/usr/bin/python
#
#  vacd - Vac daemon which runs on factory nodes
#
#  Andrew McNab, University of Manchester.
#  Copyright (c) 2013-5. All rights reserved.
#
#  Redistribution and use in source and binary forms, with or
#  without modification, are permitted provided that the following
#  conditions are met:
#
#    o Redistributions of source code must retain the above
#      copyright notice, this list of conditions and the following
#      disclaimer. 
#    o Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials
#      provided with the distribution. 
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
#  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
#  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
#  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.
#
#  Contacts: Andrew.McNab@cern.ch  http://www.gridpp.ac.uk/vac/
#

import uuid
import os, errno, sys
import json
import time
import subprocess
import socket
import shutil
import tempfile
import hashlib
import base64
import multiprocessing
import stat
import random

import libvirt

import vac

def vacLibvirtErrorHandler(ctxt, err):
    global errno    
    errno = err            
      
def pollFactories():

   responses = vac.shared.sendVmtypesRequests()

   # Total HS06 of running/starting VMs per vmtype
   factoryVmtypeTotals             = {}
   
   # Time in Unix seconds of the most recent abort, for each vmtype
   factoryVmtypeLastAborts         = {}
   
   # Number of VMs starting or not yet running for at least fizzle_seconds, for each vmtype
   factoryVmtypeNumberBeforeFizzle = {}

   # Go through the vmtypes and their responses from the factories
   for vmtypeName in vac.shared.vmtypes:
     if vac.shared.vmtypes[vmtypeName]['share'] <= 0.0:
       continue

     factoryVmtypeTotals[vmtypeName]             = 0.0
     factoryVmtypeLastAborts[vmtypeName]         = 0
     factoryVmtypeNumberBeforeFizzle[vmtypeName] = 0

     for factoryName in responses:
       response = responses[factoryName]['vmtypes'][vmtypeName]

       # we only have to add hs06/share for this vmtype to get normalisation at the end automatically
       factoryVmtypeTotals[vmtypeName] += response['total_hs06'] / vac.shared.vmtypes[vmtypeName]['share']
       vac.vacutils.logLine(factoryName + ' responds, running total for ' + vmtypeName +
                            ' now ' + str(factoryVmtypeTotals[vmtypeName]))
                               
       factoryVmtypeNumberBeforeFizzle[vmtypeName] += response['num_before_fizzle']

       try:
         # if message with code provided, then we always use it for decisions
         messagecode = int(response['shutdown_message'][0:3])
       except:
         pass
       else:
         if (messagecode >= 300) and (messagecode <= 699):
           # This is an abort!
           #
           # 300 is no work, 400 is banned, 500 is problem with VM/Site
           # 600 is grid-wide problem with job agent or application in VM
           # (VMs can return 700 for transient problems within the VM)
           
           # If this is the most recent abort of this vmtype anywhere in this space
           if response['shutdown_time'] > factoryVmtypeLastAborts[vmtypeName]:
             factoryVmtypeLastAborts[vmtypeName] = response['shutdown_time']
                      
   vac.vacutils.logLine('Final totals ' + str(factoryVmtypeTotals) + ' HS06')

   preferredVmtypeName = None

   # Go through the vmtypes, trying to pick the best one to start:
   # - Target share must be > 0.0
   # - If there has been an abort, it must be at least backoff_second ago
   # - We extend this backoff by fizzle_seconds if any other VMs of this
   #     vmtype are starting or not yet running for fizzle_seconds
   #
   # This procedure aims to give one VM the chance to try a vmtype when the
   # initial backoff_seconds following an abort expires. Rather than have
   # many VMs all trying to run as vmtype immediately. In practice, more 
   # than one may win the race to be the "first" to try, but this should
   # still be a manageable number for the experiment's Matcher/Task Queue. 
      
   for vmtypeName, vmtype in vac.shared.vmtypes.iteritems():
      if vmtype['share'] > 0.0:
           vac.vacutils.logLine('For ' + vmtypeName + ', ' +
                                str(factoryVmtypeNumberBeforeFizzle[vmtypeName]) + ' are before fizzle_time. ' +
                                'LastAbort was ' + time.strftime('%b %d %H:%M:%S', time.localtime(factoryVmtypeLastAborts[vmtypeName])) +
                                '. VM creation restart at ' +
                                time.strftime('%b %d %H:%M:%S',
                                              time.localtime(factoryVmtypeLastAborts[vmtypeName] +
                                                             vmtype['backoff_seconds'] +
                                                             vac.shared.vmtypes[vmtypeName]['fizzle_seconds'] * (factoryVmtypeNumberBeforeFizzle[vmtypeName] > 0))) + 
                                '.')

      if ((vmtype['share'] > 0.0) and 
          (factoryVmtypeLastAborts[vmtypeName] 
              < (int(time.time()) 
                 - vmtype['backoff_seconds'] 
                 - vac.shared.vmtypes[vmtypeName]['fizzle_seconds'] * (factoryVmtypeNumberBeforeFizzle[vmtypeName] > 0)))):
                      if not preferredVmtypeName:
                        preferredVmtypeName = vmtypeName
                      elif factoryVmtypeTotals[vmtypeName] < factoryVmtypeTotals[preferredVmtypeName]:
                        preferredVmtypeName = vmtypeName

   return preferredVmtypeName

def vacOneCycle():

   # Update factory heartbeat file
   vac.vacutils.createFile('/var/lib/vac/factory-heartbeat', str(int(time.time())) + '\n', stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH, '/var/lib/vac/tmp')

   readConfError = vac.shared.readConf()
   
   if readConfError:
     vac.vacutils.logLine('Reading configuration fails with: ' + readConfError)
     return
      
   # Check we can talk to the hypervisor
   # This is important at (re)start time and lets us wait till things are ok
   try:
     conn = libvirt.open(None)
   except:
     vac.vacutils.logLine('Failed to open libvirt connection')
     return
   else:     
     conn.close()

   if vac.shared.deleteOldFiles:
     vac.shared.cleanupVirtualmachineFiles()
   
   vac.shared.cleanupLoggedMachineoutputs()

   vac.shared.cleanupExports()

   if not os.path.exists('/var/lib/vac/factory-daily') or \
      time.time() > (os.stat('/var/lib/vac/factory-daily').st_ctime + 86400.0):
         vac.vacutils.createFile('/var/lib/vac/factory-daily', '', stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH, '/var/lib/vac/tmp')
   
         if vac.shared.versionLogger:
           try:
             sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
             sock.sendto(json.dumps({'space':vac.shared.spaceName, 'factory':os.uname()[1], 'version':vac.shared.vacVersion}),
                         ('vac-version-logger.gridpp.ac.uk',8884))
             sock.close()
           except:
             pass

   # Check and possibly (re)create Vac NAT network
   if not vac.shared.checkNetwork():
      # In case of unresolvable problems, we end this cycle
      return

   vac.vacutils.logLine('VMs available to this factory machine: ' + str(vac.shared.virtualmachines))
   vac.vacutils.logLine('VM Types configuration: ' + str(vac.shared.vmtypes))
   vac.vacutils.logLine('Factories in the space ' + vac.shared.spaceName + ': ' + str(vac.shared.factories))
   
   # These are updated at the END of each cycle of the for loop
   # --> So we do not use  continue  within this loop! <--
   totalCount    = 0
   runningCount  = 0
   startedOne    = False
   
   for vmname in sorted(vac.shared.virtualmachines):
   
     vm = vac.shared.VacVM(vmname)

     if hasattr(vm, 'shutdownMessage') and vm.shutdownMessage and (vm.shutdownMessage[0] == '3'):
      vac.vacutils.logLine(vm.name + ' is ' + vm.state + ' (' + str(vm.vmtypeName) + ' "' + vm.shutdownMessage + '" ' + str(vm.uuidStr) + 
                           ') Minimum ' + str(vm.vmtypeName) + ' fizzle_seconds=' + str(vm.heartbeat - vm.started) + ' ?')
     elif hasattr(vm, 'shutdownMessage') and vm.shutdownMessage:
      vac.vacutils.logLine(vm.name + ' is ' + vm.state + ' (' + str(vm.vmtypeName) + ' "' + vm.shutdownMessage + '" ' + str(vm.uuidStr) + ')')
     else:
      vac.vacutils.logLine(vm.name + ' is ' + vm.state + ' (' + str(vm.vmtypeName) + ' "" ' + str(vm.uuidStr) + ')')
     
     if vm.state == vac.shared.VacState.running:
       # VM is happily running so we redo the machine's heartbeat file
       vm.createHeartbeatFile()

       # ah, but are WE happy that it is still running?
       try:
           if int(time.time()) > vm.shutdownTime:
             vac.vacutils.logLine('VM ' + vm.name + ' has passed shutdowntime without stopping - destroying!')
             vm.destroyVM()
       except:
           pass
           
       # if a heartbeat_file is defined for this vmtype and fizzle_seconds is non-zero
       # and fizzle_seconds time has passed since the VM started...
       if 'heartbeat_file' in vac.shared.vmtypes[vm.vmtypeName] and \
          (vac.shared.vmtypes[vm.vmtypeName]['fizzle_seconds'] > 0) and \
          (int(time.time()) > (vm.started + vac.shared.vmtypes[vm.vmtypeName]['fizzle_seconds'])):

          try:
            mtime = int(os.stat('/var/lib/vac/machines/' + vmname + '/' + vm.vmtypeName + '/' + \
                            vm.uuidStr + '/shared/machineoutputs/' + vac.shared.vmtypes[vm.vmtypeName]['heartbeat_file']).st_mtime)
          except:
            #  destroy VM if file does not exist (even if heartbeat_seconds is zero)
            vac.vacutils.logLine('VM ' + vm.name + ' has passed fizzle_seconds (' + 
                        str(vac.shared.vmtypes[vm.vmtypeName]['fizzle_seconds']) + ') but no heartbeat file (' + 
                        vac.shared.vmtypes[vm.vmtypeName]['heartbeat_file'] + ') has been created - destroying!')
            vm.destroyVM()
          else:
            # if heartbeat_seconds is set, we check the file is recent
            if (vac.shared.vmtypes[vm.vmtypeName]['heartbeat_seconds'] > 0) and \
               (int(time.time()) > (mtime + vac.shared.vmtypes[vm.vmtypeName]['heartbeat_seconds'])):

              vac.vacutils.logLine('VM ' + vm.name + ' has gone ' + str(int(time.time()) - mtime) + 
                          ' seconds without updating heartbeat file (' + 
                          vac.shared.vmtypes[vm.vmtypeName]['heartbeat_file'] + ') - destroying!')
              vm.destroyVM()

     elif vm.state == vac.shared.VacState.zombie:
       # VM running but no corresponding vac directory structure
       # We kill zombies on sight! 
       vac.vacutils.logLine('VM ' + vm.name + ' running without vac directories - destroying!')
       vm.destroyVM()
       
     elif vm.state == vac.shared.VacState.paused:
       # suspended internally somehow? kill it to be safe
       vac.vacutils.logLine('VM ' + vm.name + ' paused without shutting down - destroying!')
       vm.destroyVM()

     if vm.state == vac.shared.VacState.starting and vm.vmtypeName:
       vac.vacutils.logLine('VM ' + vm.name + ' still in starting state in a new cycle - cleaning up!')
       # If VM is still starting and we've come round again, then starting failed!
       vm.state = vac.shared.VacState.shutdown
       # Something has gone wrong, so we clean up
       vac.shared.cleanupByNameUUID(vm.name, vm.vmtypeName, vm.uuidStr)

     if vm.state == vac.shared.VacState.shutdown:
       # create the finished file for the responder if not already there
       if vm.started and not vm.finishedFile:
               vm.writeApel()
               if vac.shared.vmtypes[vm.vmtypeName]['log_machineoutputs']:
                 vm.logMachineoutputs()
               vac.vacutils.logLine('Create finished file for ' + vm.name)
               vm.createFinishedFile()

       elif not vm.finishedFile:
               vac.vacutils.logLine('No finished file but no started time for ' + vm.name)
  
       # we will only start one VM per cycle
       if startedOne:
         vac.vacutils.logLine('VM not recreated because one already recreated this cycle')
       else:
         # count up the running VMs' CPUs on the this factory
         totalCpusForCount = 0
  
         for vmnameForCount in vac.shared.virtualmachines:
           vmForCount = vac.shared.VacVM(vmnameForCount)

           if vmForCount.state == vac.shared.VacState.running:
              totalCpusForCount += vmForCount.cpus
              
         # as VM is shutdown, we see if we can restart it
         if vac.shared.loadAvg() > (vac.shared.overloadPerCpu * vac.shared.cpuCount):
           vac.vacutils.logLine('VM not recreated as load average is > overload_per_cpu(' + str(vac.shared.overloadPerCpu) + ') * cpu count(' + str(vac.shared.cpuCount) + ')')
         elif (totalCpusForCount + vac.shared.cpuPerMachine) > vac.shared.numCpus:
           vac.vacutils.logLine('VM not recreated due to cpu_total or /proc/cpuinfo limit (' + str(vac.shared.numCpus) + ')')
         elif vac.shared.shutdownTime and (vac.shared.shutdownTime < int(time.time())):
           vac.vacutils.logLine('VM not recreated as shutdown_time = ' + str(vac.shared.shutdownTime) + ' has already passed')
         else:
           vac.vacutils.logLine('Query factories and try to recreate ' + vm.name)
           preferredVmtypeName = pollFactories()
       
           if preferredVmtypeName:
             vac.vacutils.logLine('Creating ' + vm.name + ' with vmtype ' + preferredVmtypeName)
             createError = vm.createVM(preferredVmtypeName)

             if createError:
               vac.vacutils.logLine('VM creation fails with: ' + createError)
               vac.vacutils.createFile('/var/lib/vac/factory-error', 'VM creation fails with: ' + createError, stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH, '/var/lib/vac/tmp')
             else:
               # we update heartbeat after creating a VM in case that took a while
               # (several minutes for Xen, without COW disk images)
               vac.vacutils.createFile('/var/lib/vac/factory-heartbeat', str(int(time.time())) + '\n', stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH, '/var/lib/vac/tmp')

               # remember we've started one this cycle
               startedOne = True

               # if no VM creation errors, then cleanup any old message   
               try:
                 os.remove('/var/lib/vac/factory-error')
               except OSError:
                 pass
           else:
             vac.vacutils.logLine('No vmtype suitable for creation in this cycle')

     # finished with this vm, update counts
     totalCount += 1

     # the createVM and destroyVM methods update VacVM.state
     if vm.state == vac.shared.VacState.running:
       runningCount += 1

   # finished with all VMs, so output counts for Nagios etc
   vac.vacutils.createFile('/var/lib/vac/counts', 'total=%d running=%d\n' % (totalCount,runningCount), stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH, '/var/lib/vac/tmp')

def sendMachineResponses(sock, cookie, addr):
   
   # Go through the machine slots, sending one message for each
   for vmName in sorted(vac.shared.virtualmachines):

     newestUUID       = None
     newestCtime      = None
     newestVmtypeName = None

     # Find which vmtype is the most recent for this machine
     for vmtypeName in vac.shared.vmtypes.keys():

       try:
         dirslist = os.listdir('/var/lib/vac/machines/' + vmName + '/' + vmtypeName)
       except:
         continue

       # Find the most recent instance of this vmtypeName for this vmName
       for onedir in dirslist:
         try:
           ctime = int(os.stat('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + onedir + '/created').st_ctime)
         except:
           pass
         else:
           if not newestUUID or (ctime > newestCtime):
             newestCtime      = ctime
             newestUUID       = onedir
             newestVmtypeName = vmtypeName

     # Found the newest instance in this machine slot
     if newestUUID:

       print vmName,newestUUID
                
       try:
         startedStat = os.stat('/var/lib/vac/machines/' + vmName + '/' + newestVmtypeName + '/' + newestUUID + '/started')
         timeStarted = int(startedStat.st_ctime)
       except:
         timeStarted = None
                             
       try:
         heartbeatStat = os.stat('/var/lib/vac/machines/' + vmName + '/' + newestVmtypeName + '/' + newestUUID + '/heartbeat')
         timeHeartbeat = int(heartbeatStat.st_ctime)
       except:
         timeHeartbeat = None

       try:                  
         f = open('/var/lib/vac/machines/' + vmName + '/' + newestVmtypeName + '/' + newestUUID + '/shared/machinefeatures/hs06', 'r')
         hs06 = float(f.readline().strip())
         f.close()
       except:
         hs06 = vac.shared.hs06PerMachine

       try:
         # this is written by Vac as it monitors the machine through libvirt
         f = open('/var/lib/vac/machines/' + vmName + '/' + newestVmtypeName + '/' + newestUUID + '/heartbeat', 'r')
         oneLine = f.readline()
         f.close()
                                    
         cpuSeconds = int(oneLine.split(' ')[0])
         try:
           cpuPercentage = float(oneLine.split(' ')[1])
         except:
           cpuPercentage = None
                    
       except:
         cpuSeconds    = None
         cpuPercentage = None

       hasFinished = os.path.exists('/var/lib/vac/machines/' + vmName + '/' + newestVmtypeName + '/' + newestUUID + '/finished')

       shutdownMessage     = None
       shutdownMessageTime = None

       # some hardcoded timeouts in case old files are left lying around 
       # this means that old files are ignored when working out the state
       if (timeStarted and 
           timeHeartbeat and 
           (timeHeartbeat > int(time.time() - 3600)) and
           not hasFinished):
         vmState = vac.shared.VacState.running
       elif not timeStarted and (newestCtime > int(time.time() - 3600)):
         vmState = vac.shared.VacState.starting
       else:
         vmState = vac.shared.VacState.shutdown

         try:
           f = open('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUIDByVmtype + '/shared/machineoutputs/shutdown_message')
           shutdownMessage = f.readline().strip()
           f.close()
           shutdownMessageTime = int(os.stat('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUIDByVmtype + 
                                                    '/shared/machineoutputs/shutdown_message').st_ctime)
         except:
           pass
                                                                                                                         
       vac.vacutils.logLine(vmName + ' is ' + str(vmState) + ' (' + str(vmtypeName) + ', started ' + str(newestCtime) + ')')

       try:
         sock.sendto(json.dumps({
                'method'		: 'machine',
                'vac_version'		: 'Vac ' + vac.shared.vacVersion,
                'vacquery_version'	: 'VacQuery ' + vac.shared.vacQueryVersion,
                'cookie'	  	: cookie,
                'space'		    	: vac.shared.spaceName,
                'factory'       	: os.uname()[1],
                'num_machines'       	: len(vac.shared.virtualmachines),

                'machine' 		: vmName,
                'state'			: vmState,
                'uuid'			: newestUUID,
                'created_time'		: newestCtime,
                'started_time'		: timeStarted,
                'heartbeat_time'	: timeHeartbeat,
                'cpu_seconds'		: cpuSeconds,
                'cpu_percentage'	: cpuPercentage,
                'hs06' 		       	: hs06,
                'vmtype'		: vmtypeName,
                'shutdown_message'  	: shutdownMessage,
                'shutdown_time'     	: shutdownMessageTime
                              }), addr)

       except socket.error as msg:
             pass

def sendVmtypeResponses(sock, cookie, addr):
   # Send back vmtype messages to the querying factory or client

   # Go through the vmtypes
   for vmtypeName in vac.shared.vmtypes:

     totalHS06               = 0.0
     lastShutdownMessage     = None
     lastShutdownMessageTime = None
     lastMachineName         = None
     numBeforeFizzle         = 0

     # Go through the VMs' instances of this vmtype
     for vmName in sorted(vac.shared.virtualmachines):

       try:
         dirslist = os.listdir('/var/lib/vac/machines/' + vmName + '/' + vmtypeName)
       except:
         continue

       newestUUID  = None
       newestCtime = None

       for onedir in dirslist:
         try:
           ctime = int(os.stat('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + onedir + '/created').st_ctime)
         except:
           pass
         else:
           if not newestUUID or (ctime > newestCtime):
             newestCtime = ctime
             newestUUID  = onedir

       # if we find an instance for this vmtype, get its state
       if newestUUID:
         
         try:
           startedStat = os.stat('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUID + '/started')
           timeStarted = int(startedStat.st_ctime)
         except:
           timeStarted = None

         try:
           heartbeatStat = os.stat('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUID + '/heartbeat')
           timeHeartbeat = int(heartbeatStat.st_ctime)
         except:
           timeHeartbeat = None

         try:                  
           f = open('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUID + '/shared/machinefeatures/hs06', 'r')
           hs06 = float(f.readline().strip())
           f.close()
         except:
           hs06 = vac.shared.hs06PerMachine

         hasFinished = os.path.exists('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUID + '/finished')

         # some hardcoded timeouts here in case old files are left lying around 
         # this means that old files are ignored when working out the state
         if (timeStarted and 
             timeHeartbeat and 
             (timeHeartbeat > int(time.time() - 3600)) and
             not hasFinished):
           vmState = vac.shared.VacState.running
           totalHS06 += hs06

           if int(time.time()) < timeStarted + vac.shared.vmtypes[vmtypeName]['fizzle_seconds']:
             numBeforeFizzle += 1

         elif not timeStarted and (newestCtime > int(time.time() - 3600)):
           vmState          = vac.shared.VacState.starting
           totalHS06       += hs06
           numBeforeFizzle += 1

         else:
           vmState = vac.shared.VacState.shutdown

           try:
             f = open('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUID + '/shared/machineoutputs/shutdown_message')
             shutdownMessage = f.readline().strip()
             f.close()
             messageCode = int(shutdownMessage[0:3])
             shutdownMessageTime = int(os.stat('/var/lib/vac/machines/' + vmName + '/' + vmtypeName + '/' + newestUUID + 
                                               '/shared/machineoutputs/shutdown_message').st_ctime)
           except:
             # No explicit shutdown message with a message code, so we make one up if necessary
             if timeStarted and timeHeartbeat and (timeHeartbeat - timeStarted < vac.shared.vmtypes[vmtypeName]['fizzle_seconds']):
               shutdownMessageTime = timeHeartbeat
               shutdownMessage = '300 Abort after ' + str(timeHeartbeat - timeStarted) + ' seconds'
                          
           if shutdownMessage and shutdownMessageTime and \
              (lastShutdownMessageTime is None or \
               shutdownMessageTime > lastShutdownMessageTime):
               
             lastShutdownMessage     = shutdownMessage
             lastShutdownMessageTime = shutdownMessageTime
             lastMachineName         = vmName
                                                        
     try:
       sock.sendto(json.dumps({
                'method'		: 'machinetype',
                'vac_version'		: 'Vac ' + vac.shared.vacVersion,
                'vacquery_version'	: 'VacQuery ' + vac.shared.vacQueryVersion,
                'cookie'	  	: cookie,
                'space'		    	: vac.shared.spaceName,
                'factory'       	: os.uname()[1],
                'num_vmtypes'       	: len(vac.shared.vmtypes),

                'vmtype'		: vmtypeName,
                'total_hs06'        	: totalHS06,
                'num_before_fizzle' 	: numBeforeFizzle,
                'shutdown_message'  	: lastShutdownMessage,
                'shutdown_time'     	: lastShutdownMessageTime,
                'shutdown_machine'  	: lastMachineName
                              }), addr)

     except socket.error as msg:
       pass

def sendFactoryResponse(sock, cookie, addr):
   # Send back factory status message to the querying client

   vacDiskStatFS  = os.statvfs('/var/lib/vac')
   rootDiskStatFS = os.statvfs('/tmp')
   
   memory = vac.shared.memInfo()

   try:
       sock.sendto(json.dumps({
                'method'		   : 'factory',
                'vac_version'		   : 'Vac ' + vac.shared.vacVersion,
                'vacquery_version'	   : 'VacQuery ' + vac.shared.vacQueryVersion,
                'cookie'	  	   : cookie,
                'space'		    	   : vac.shared.spaceName,
                'factory'       	   : os.uname()[1],
                'time_sent'		   : int(time.time()),			
                'num_cpus'		   : vac.shared.numCpus,
                'total_hs06'		   : vac.shared.numCpus * vac.shared.hs06PerMachine / vac.shared.cpuPerMachine,
                'vac_disk_avail_kb'        : ( vacDiskStatFS.f_bavail *  vacDiskStatFS.f_frsize) / 1024,
                'root_disk_avail_kb'       : (rootDiskStatFS.f_bavail * rootDiskStatFS.f_frsize) / 1024,
                'vac_disk_avail_inodes'    :  vacDiskStatFS.f_favail,
                'root_disk_avail_inodes'   : rootDiskStatFS.f_favail,
                'load_average'		   : vac.shared.loadAvg(2),
                'kernel_version'	   : os.uname()[2],
                'factory_heartbeat_time'   : int(os.stat('/var/lib/vac/factory-heartbeat').st_ctime),
                'responder_heartbeat_time' : int(os.stat('/var/lib/vac/responder-heartbeat').st_ctime),
                'swap_used_kb'		   : memory['SwapTotal'] - memory['SwapFree'],
                'swap_free_kb'		   : memory['SwapFree'],
                'mem_used_kb'		   : memory['MemTotal'] - memory['MemFree'],
                'mem_total_kb'		   : memory['MemTotal']
                              }), addr)

   except socket.error as msg:
       pass

def vacResponder():

   si = file('/dev/null', 'r')
   os.dup2(si.fileno(), sys.stdin.fileno())

   so = file('/var/log/vacd-responder', 'a+')
   os.dup2(so.fileno(), sys.stdout.fileno())
          
   se = file('/var/log/vacd-responder', 'a+', 0)     
   os.dup2(se.fileno(), sys.stderr.fileno())
 
   vac.vacutils.createFile('/var/lib/vac/responder.pid', str(os.getpid()) + '\n', stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH, '/var/lib/vac/tmp')

   sock = None

   vac.vacutils.logLine('vac responder starts')
   
   vac.shared.setProcessName('vacd-responder')

   while True:
   
     try:
       close(so)
     except:
       pass
           
     so = file('/var/log/vacd-responder', 'a+')
     os.dup2(so.fileno(), sys.stdout.fileno())
          
     try:
       close(se)
     except:
       pass

     se = file('/var/log/vacd-responder', 'a+', 0)     
     os.dup2(se.fileno(), sys.stderr.fileno())

     if sock is None:
       sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
       vac.shared.setSockBufferSize(sock)
       sock.settimeout(60.0)

       try:
         sock.bind(('', 995))
       except Exception as e:
         sock = None
         vac.vacutils.logLine('Failed to bind to vac-responder port 995: ' + str(e))
         time.sleep(60.0)
         continue
   
     readConfError = vac.shared.readConf()

     if readConfError:
       vac.vacutils.logLine('Reading configuration fails with: ' + readConfError)
       time.sleep(60.0)
       continue
          
     try:
       pr = open('/var/lib/vac/responder.pid', 'r')
       pid = int(pr.read().strip())
       pr.close()
       
       if pid != os.getpid():
         vac.vacutils.logLine('os.getpid ' + os.getpid() + ' does not match responder.pid ' + pid + ' - exiting')
         break
                
     except:
       vac.vacutils.logLine('no responder.pid - exiting')
       break

     # so log file is updated before we start waiting        
     sys.stdout.flush()
     sys.stderr.flush()

     # Update responder heartbeat file
     vac.vacutils.createFile('/var/lib/vac/responder-heartbeat', str(int(time.time())) + '\n', stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH, '/var/lib/vac/tmp')

     try:
       data, addr = sock.recvfrom(1024)
     except socket.error as msg:
       continue

     try:
       queryMessage = json.loads(data)
     except:
       continue
     
     if ('space'  in queryMessage and 
         'cookie' in queryMessage and 
         'method' in queryMessage and 
         queryMessage['space']  == vac.shared.spaceName):
          
         vac.vacutils.logLine("Received " + data + " from " + str(addr))

         if queryMessage['method'] == 'machines':
           sendMachineResponses(sock, queryMessage['cookie'], addr)
 
         elif queryMessage['method'] == 'machinetypes':
           sendVmtypeResponses(sock, queryMessage['cookie'], addr)

         elif queryMessage['method'] == 'factories':
           sendFactoryResponse(sock, queryMessage['cookie'], addr)

   sys.exit(0) # if we break out of while loop then we exit

#
# PROGRAM MAIN !!!
# 

libvirt.registerErrorHandler(vacLibvirtErrorHandler, 'context')

if __name__ == '__main__':

    if (os.fork() != 0):
      sys.exit() # first parent

    else:
      os.chdir("/")
      os.setsid()
      os.umask(0) 

      if os.fork() != 0:
        sys.exit() # second parent

      else:
             
        if os.fork() == 0:

          vacResponder()

        else:
          try:
             os.remove('/var/lib/vac/factory-daily')
          except:
             pass

          vac.vacutils.createFile('/var/lib/vac/factory.pid', str(os.getpid()) + '\n', stat.S_IWUSR + stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH, '/var/lib/vac/tmp')
          
          vac.shared.setProcessName('vacd-factory')

          si = file('/dev/null', 'r')
          os.dup2(si.fileno(), sys.stdin.fileno())

          while True:
          
            try:
              close(so)
            except:
              pass
           
            so = file('/var/log/vacd-factory', 'a+')
            os.dup2(so.fileno(), sys.stdout.fileno())
          
            try:
              close(se)
            except:
              pass

            se = file('/var/log/vacd-factory', 'a+', 0)     
            os.dup2(se.fileno(), sys.stderr.fileno())

            try:
               pf = open('/var/lib/vac/factory.pid', 'r')
               pid = int(pf.read().strip())
               pf.close()
       
               if pid != os.getpid():
                 print 'new factory.pid - exiting'
                 break
                
            except:
               print 'no factory.pid - exiting'
               break

            # Fork a subprocess to run each cycle          
            cyclePid = os.fork()
        
            # Otherwise each subprocess starts from the same point in the sequence!
            random.seed()

            if cyclePid == 0:
              vac.vacutils.logLine('=============== Start cycle ===============')
              vacOneCycle()
              vac.vacutils.logLine('================ End cycle ================')
              sys.exit(0)

            # wait for cyclePid subprocess to finish
            os.waitpid(cyclePid, 0)

            time.sleep(60)
 
          sys.exit(0) # if we break out of the while loop, then we exit
          