#!/usr/bin/python
#
#  vacd - Vac daemon which runs on factory nodes
#
#  Andrew McNab, University of Manchester.
#  Copyright (c) 2013. All rights reserved.
#
#  Redistribution and use in source and binary forms, with or
#  without modification, are permitted provided that the following
#  conditions are met:
#
#    o Redistributions of source code must retain the above
#      copyright notice, this list of conditions and the following
#      disclaimer. 
#    o Redistributions in binary form must reproduce the above
#      copyright notice, this list of conditions and the following
#      disclaimer in the documentation and/or other materials
#      provided with the distribution. 
#
#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
#  CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
#  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
#  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
#  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
#  BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
#  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
#  TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
#  ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
#  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
#  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#  POSSIBILITY OF SUCH DAMAGE.
#
#  Contacts: Andrew.McNab@cern.ch  http://www.gridpp.ac.uk/vac/
#

import uuid
import os, errno, sys
import json
import time
import subprocess
import socket
import shutil
import tempfile
import hashlib,base64
import multiprocessing
import libvirt
import VAC
from stat import *

def vacLibvirtErrorHandler(ctxt, err):
    global errno    
    errno = err            
      
def cleanupByNameUUID(name, uuidStr):
   conn = libvirt.open(None)
   if conn == None:
      print 'Failed to open connection to the hypervisor'
      raise
          
   try:
      dom = conn.lookupByUUIDString(uuidStr)
      dom.destroy()
   except:
      pass

   f = os.popen('exportfs', 'r')
   pathname = f.readline().strip()

   while pathname and name:
      if ('/var/lib/vac/machines/' + name + '/' + self.vmtypeName + '/' + uuidStr + '/shared' == pathname):
         os.system('exportfs -u ' + name + ':' + pathname)

      pathname = f.readline().strip()

   f.close()

   shutil.rmtree('/var/lib/vac/machines/' + name + '/' + uuidStr, 1)
   
def cleanupExports():

   conn = libvirt.open(None)
   if conn == None:
        print 'Failed to open connection to the hypervisor'
        raise

   f = os.popen('exportfs', 'r')
   pathname  = f.readline().strip()
   pathsplit = pathname.split('/')
   
   while pathname:

      #  /var/lib/vac/machines/f.q.d.n/vmtype/UUID/shared
      # 0  1   2   3      4       5      6     7     8

      if (len(pathsplit) > 8) and pathsplit[0] == '' and pathsplit[1] == 'var' and \
         pathsplit[2] == 'lib' and pathsplit[3] == 'vac' and pathsplit[4] == 'machines' and \
         pathsplit[8] == 'shared':
     
            try:
              dom = conn.lookupByUUIDString(pathsplit[7])

            except: 
              print 'Remove now unused export of',pathname
              os.system('exportfs -u ' + pathsplit[5] + ':' + pathname) 
    
      pathname  = f.readline().strip()
      pathsplit = pathname.split('/')

   f.close()
   conn.close()
   
def cleanupVirtualmachineFiles():
   #
   # THIS FUNCTION CAN ONLY BE RUN INSIDE THE MAIN LOOP
   # ie the same level as where VacVM.createVM() is
   # called. Otherwise active directories may be deleted!
   # 

   for vmname in VAC.virtualmachines:
     vm = VAC.VacVM(vmname)

     # we delete the disk images if the VM is shutdown
     if vm.state == VAC.VacState.shutdown:
       try:
          if VAC.domainType == 'kvm':
            os.remove('/var/lib/vac/machines/' + vm.name + '/' + vm.vmtypeName + '/' + vm.uuidStr + '/sparse-root.qcow2')
            VAC.logLine('Deleting /var/lib/vac/machines/' + vm.name + '/' + vm.vmtypeName + '/' + vm.uuidStr + '/sparse-root.qcow2')
          elif VAC.domainType == 'xen':
            os.remove('/var/lib/vac/machines/' + vm.name + '/root.disk')
            VAC.logLine('Deleting /var/lib/vac/machines/' + vm.name + '/root.disk')
       except:
          pass
                    
     # we go through the vmtypes, looking for directory
     # hierarchies that aren't the current VM instance.
     # 'current' includes the last used hierarchy if the
     # VM state is shutdown
     for vmtypeName, vmtype in VAC.vmtypes.iteritems():
       try:
         dirslist = os.listdir('/var/lib/vac/machines/' + vmname + '/' + vmtypeName)
       except:
         continue

       for onedir in dirslist:
         if (os.path.isdir('/var/lib/vac/machines/' + vmname + '/' + vmtypeName + '/' + onedir) 
             and (not vm.uuidStr or vm.uuidStr != onedir)):
           shutil.rmtree('/var/lib/vac/machines/' + vmname + '/' + vmtypeName + '/' + onedir)
           VAC.logLine('Deleting /var/lib/vac/machines/' + vmname + '/' + vmtypeName + '/' + onedir)
   
def pollFactories():

   factoryVmtypeTotals     = {}
   factoryVmtypeLastAborts = {}

   for vmtypeName, vmtype in VAC.vmtypes.iteritems():
      if (vmtype['share'] > 0.0):
        factoryVmtypeTotals[vmtypeName]     = 0.0
        factoryVmtypeLastAborts[vmtypeName] = 0

   salt = base64.b64encode(os.urandom(32))
   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
   sock.settimeout(5.0)

   for factoryName in VAC.factories:
      sock.sendto(json.dumps({'cookie':hashlib.sha256(salt + factoryName).hexdigest(), 
                              'method':'status'}),(factoryName,995))
   while True:
   
      try:
           data, addr = sock.recvfrom(10240)
                      
           try:
                response = json.loads(data)
           except:
              VAC.logLine('json.loads failed for ' + data)
              continue

           if 'cookie' 			in response and \
              'factoryname'		in response and \
              'method'			in response and \
              response['method'] == 'status' and \
              response['cookie'] == hashlib.sha256(salt + response['factoryname']).hexdigest() :

              if 'state'		in response and \
                 'vmtype'		in response and \
                 response['vmtype']	in VAC.vmtypes and \
                 (response['state'] == VAC.VacState.starting or response['state'] == VAC.VacState.running) and \
                 VAC.vmtypes[response['vmtype']]['share'] > 0.0:
                   # we only have to add 1.0/share for this vmtype to get normalisation at the end automatically
                   factoryVmtypeTotals[response['vmtype']] += 1.0 / VAC.vmtypes[response['vmtype']]['share']           
                   VAC.logLine(response['factoryname'] + ' responds, running total for ' + response['vmtype'] + 
                               ' now ' + str(factoryVmtypeTotals[response['vmtype']]))
                   
              if 'vmtypeslist' in response:
                for vmtypeOutcome in response['vmtypeslist']:
                  try:
                    abortTime = None

                    if 'messagetime' in vmtypeOutcome and 'message' in vmtypeOutcome and vmtypeOutcome['message'][0:3].isdigit():
                      # if message with code provided, then we always use it for decisions
                      messagecode=int(vmtypeOutcome['message'][0:3])
                      if messagecode >= 300 and messagecode <= 599:
                        # 300 is no work, 400 is banned, 500 is problem with VM/Site
                        abortTime = vmtypeOutcome['messagetime']
                    else:
                      # no message, so we have to use times to identify fizzles
                      if vmtypeOutcome['state'] == VAC.VacState.shutdown and \
                         started in vmtypeOutcome and heartbeat in vmtypeOutcome and \
                         vmtypeOutcome['heartbeat'] < vmtypeOutcome['started'] + VAC.vmtypes[vmtypeOutcome['vmtype']]['fizzle_seconds']:
                        abortTime = vmtypeOutcome['heartbeat']

                    if abortTime and abortTime > factoryVmtypeLastAborts[vmtypeOutcome['vmtype']]:
                      factoryVmtypeLastAborts[vmtypeOutcome['vmtype']] = abortTime
                      
                  except:
                    continue     
     
      except socket.error as msg:
           break

   VAC.logLine('Final totals ' + str(factoryVmtypeTotals))

   preferredVmtypeName = None
      
   for vmtypeName, vmtype in VAC.vmtypes.iteritems():
      if vmtype['share'] > 0.0 and factoryVmtypeLastAborts[vmtypeName] < int(time.time()) - vmtype['backoff_seconds']:          
          if not preferredVmtypeName:
                preferredVmtypeName = vmtypeName
          elif factoryVmtypeTotals[vmtypeName] < factoryVmtypeTotals[preferredVmtypeName]:
                preferredVmtypeName = vmtypeName
                
   return preferredVmtypeName

def vacOnePass():

   VAC.readConf()

   VAC.createFile('/var/lib/vac/heartbeat', str(int(time.time())) + '\n')
                        
   VAC.logLine('VMs available to this factory machine: ' + str(VAC.virtualmachines))
   VAC.logLine('Factories in the space: ' + str(VAC.factories))
   VAC.logLine('VM Types configuration: ' + str(VAC.vmtypes))
   
   for vmname in VAC.virtualmachines:
   
     vm = VAC.VacVM(vmname)

     if hasattr(vm, 'shutdownMessage') and vm.shutdownMessage:
      VAC.logLine(vm.name + ' is ' + vm.state + ' (' + str(vm.vmtypeName) + ' "' + vm.shutdownMessage + '" ' + str(vm.uuidStr) + ')')
     else:
      VAC.logLine(vm.name + ' is ' + vm.state + ' (' + str(vm.vmtypeName) + ' "" ' + str(vm.uuidStr) + ')')
     
     if vm.state == VAC.VacState.running:
       # happily running so we redo the heartbeat file
       # eventually move this to a watcher process?
       VAC.createFile('/var/lib/vac/machines/' + vm.name + '/' + vm.vmtypeName + '/' + 
                      vm.uuidStr + '/heartbeat', str(vm.cpuSeconds) + '\n')
       try:
           if int(time.time()) > vm.shutdownTime:
             VAC.logLine('VM ' + vm.name + ' has passed shutdowntime without stopping - destroying!')
             vm.destroyVM()
             vm.state = VAC.VacState.shutdown
       except:
           pass
                                                       
     elif vm.state == VAC.VacState.zombie:
       # VM running but no corresponding vac directory structure
       # We kill zombies on sight!
       VAC.logLine('VM ' + vm.name + ' running without vac directories - destroying!')
       vm.destroyVM()
       vm.state = VAC.VacState.shutdown
       
     elif vm.state == VAC.VacState.paused:
       VAC.logLine('VM ' + vm.name + ' paused without shutting down - destroying!')
       vm.destroyVM()
       vm.state = VAC.VacState.shutdown

     if vm.state == VAC.VacState.shutdown or vm.state == VAC.VacState.starting:
       # if VM is still starting and we've come round again, then starting failed!
       VAC.logLine('Query factories and try to recreate ' + vm.name)
       preferredVmtypeName = pollFactories()
       
       if preferredVmtypeName:
         VAC.logLine('Creating ' + vm.name + ' with vmtype ' + preferredVmtypeName)
         vm.createVM(preferredVmtypeName)
         
         # we update heartbeat after creating a VM in case that took a while
         # (several minutes for Xen, without COW disk images)
         VAC.createFile('/var/lib/vac/heartbeat', str(int(time.time())) + '\n')
       else:
         VAC.logLine('No vmtype suitable for creation in this cycle')

def vacResponder():
 
   VAC.createFile('/var/lib/vac/responder.pid', str(os.getpid()) + '\n')

   sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
   
   sock.bind(('', 995))
   
   VAC.logLine('vac responder starts')
   
   while True:
   
     try:
       pr = open('/var/lib/vac/responder.pid', 'r')
       pid = int(pr.read().strip())
       pr.close()
       
       if pid != os.getpid():
         VAC.logLine('os.getpid ' + os.getpid() + ' does not match responder.pid ' + pid + ' - exiting')
         break
                
     except:
       VAC.logLine('no responder.pid - exiting')
       break

     # so log file is updated before we start waiting        
     sys.stdout.flush()
     sys.stderr.flush()

     data, addr = sock.recvfrom(1024)
     
     try:
        query = json.loads(data)
     except:
        continue
     
     if 'cookie' in query and 'method' in query and query['method'] == 'status':
          
         VAC.readConf()
     
         VAC.logLine("Received " + data + " from " + str(addr))
    
         for vmname in VAC.virtualmachines:
     
           vm = VAC.VacVM(vmname)
           VAC.logLine(vm.name + ' is ' + vm.state + ' (' + str(vm.vmtypeName) + ' ' + str(vm.uuidStr) + ')')

           vmtypesList = []
           
           for vmtypeName, vmtype in VAC.vmtypes.iteritems():

              try:
                   dirslist = os.listdir('/var/lib/vac/machines/' + vmname + '/' + vmtypeName)
              except:
                   continue

              newestUUIDStr = None

              for onedir in dirslist:
                 if os.path.isdir('/var/lib/vac/machines/' + vmname + '/' + vmtypeName + '/' + onedir):
                   if newestUUIDStr:
                       if os.stat('/var/lib/vac/machines/' + vmname + '/' + vmtypeName + '/' + onedir).st_ctime > \
                          os.stat('/var/lib/vac/machines/' + vmname + '/' + vmtypeName + '/' + newestUUIDStr).st_ctime:
                           newestUUIDStr = onedir
                   else:
                       newestUUIDStr = onedir
                   
              if newestUUIDStr:
                
                try:
                  startedStat = os.stat('/var/lib/vac/machines/' + vmname + '/' + vmtypeName + '/' + newestUUIDStr + '/started')
                  timeStarted = int(startedStat.st_ctime)
                except:
                  timeStarted = None
                                    
                try:
                  heartbeatStat = os.stat('/var/lib/vac/machines/' + vmname + '/' + vmtypeName + '/' + newestUUIDStr + '/heartbeat')
                  timeHeartbeat = int(heartbeatStat.st_ctime)
                except:
                  timeHeartbeat = None

                try:
                  f = open('/var/lib/vac/machines/' + vmname + '/' + vmtypeName + '/' + newestUUIDStr + '/shared/machineoutputs/shutdown_message')
                  shutdownMessage = f.readline().strip()
                  f.close()
                  timeShutdownMessage = int(os.stat('/var/lib/vac/machines/' + vmname + '/' + vmtypeName + '/' + newestUUIDStr + 
                                                    '/shared/machineoutputs/shutdown_message').st_ctime)
                except:
                  shutdownMessage     = None                                    
                  timeShutdownMessage = None
                                
                vmtypesList.append({
                                     'vmtype'		: vmtypeName,
                                     'started'		: timeStarted,
                                     'heartbeat'	: timeHeartbeat,
                                     'message'		: shutdownMessage,
                                     'messagetime'	: timeShutdownMessage,
                                     'state'		: vm.state if newestUUIDStr == vm.uuidStr else VAC.VacState.shutdown
                                  })
              
           sock.sendto(json.dumps({
                'vmname'	: vm.name, 
                'uuid'		: vm.uuidStr, 
                'state'		: vm.state,
                'vmtype'	: vm.vmtypeName,
                'cookie'	: query['cookie'],
                'method'	: query['method'],
                'vmtypeslist'	: vmtypesList,
                'factoryname'	: socket.gethostbyaddr(socket.gethostname())[0]
                              }), addr)

   sys.exit(0) # if we break out of while loop then we exit

#
# PROGRAM MAIN !!!
# 

libvirt.registerErrorHandler(vacLibvirtErrorHandler, 'context')

if __name__ == '__main__':

    if (os.fork() != 0):
      sys.exit() # first parent

    else:
      os.chdir("/")
      os.setsid()
      os.umask(0) 

      if os.fork() != 0:
        sys.exit() # second parent

      else:
             
        if os.fork() == 0:

          si = file('/dev/null', 'r')
          so = file('/var/log/vacd-responder', 'a+')
          se = file('/var/log/vacd-responder', 'a+', 0)
    
          os.dup2(si.fileno(), sys.stdin.fileno())
          os.dup2(so.fileno(), sys.stdout.fileno())
          os.dup2(se.fileno(), sys.stderr.fileno())

          vacResponder()

        else:
          VAC.createFile('/var/lib/vac/factory.pid', str(os.getpid()) + '\n')
                                     
          si = file('/dev/null', 'r')
          so = file('/var/log/vacd-factory', 'a+')
          se = file('/var/log/vacd-factory', 'a+', 0)
     
          os.dup2(si.fileno(), sys.stdin.fileno())
          os.dup2(so.fileno(), sys.stdout.fileno())
          os.dup2(se.fileno(), sys.stderr.fileno())
          
          while True:

            try:
               pf = open('/var/lib/vac/factory.pid', 'r')
               pid = int(pf.read().strip())
               pf.close()
       
               if pid != os.getpid():
                 print 'new factory.pid - exiting'
                 break
                
            except:
               print 'no factory.pid - exiting'
               break

            VAC.logLine('=============== Start cycle ===============')

            if VAC.deleteOldFiles:
              cleanupVirtualmachineFiles()

            cleanupExports() 

            vacOnePass()

            sys.stdout.flush()
            sys.stderr.flush()
            time.sleep(10)
 
          sys.exit(0) # if we break out of the while loop, then we exit
          